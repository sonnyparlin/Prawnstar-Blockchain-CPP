// Transaction transaction2 = janeWallet.createTransaction(receiver, 12, tx.transfer);
    // Transaction transaction3 = janeWallet.createTransaction(receiver, 12, tx.transfer);
    // Transaction transaction4 = janeWallet.createTransaction(receiver, 12, tx.transfer);
    bool r = utils::verifySignature(transaction.payload(), transaction.signature, janeWallet.walletPublicKey);
    if (!r)
        std::cout << "Transaction signature verification failed" << std::endl;

    // TransactionPool pool;

    // if (pool.transactionExists(transaction) == false && utils::verifySignature(transaction.payload(), transaction.signature, janeWallet.walletPublicKey)) {
    //     pool.addTransaction(transaction);
    // }

    // if (pool.transactionExists(transaction2) == false) {
    //     pool.addTransaction(transaction2);
    // }

    // std::cout << "Blockchain:\n" << std::endl;
    // Block last_block = blockchain.blocks[blockchain.blocks.size()-1];
    // std::string lastHash = last_block.hash;
    // int blockCount = last_block.blockCount + 1;
    
    // Block block = sonny_wallet.createBlock(pool.transactions, lastHash, blockCount);
    
    // bool signature_valid = false;
    // if (!blockchain.lastBlockHashValid(block))
    //     std::cout << "Last block hash is not valid" << last_block.hash << std::endl;
    // if (!blockchain.blockCountValid(block))
    //     std::cout << "Last block count is not valid" << std::endl;
    // if (!utils::verifySignature(block.payload(), block.signature, sonny_wallet.walletPublicKey))
    //     std::cout << "Block signature is not valid " + block.signature << std::endl;
    // else
    //     signature_valid = true;

    // if (blockchain.lastBlockHashValid(block) 
    //         && blockchain.blockCountValid(block)
    //         && signature_valid) {    
    //     blockchain.addBlock(block);
    //     pool.transactions.clear();
    // }

    // if (pool.transactionExists(transaction3) == false) {
    //     pool.addTransaction(transaction3);
    // }

    // if (pool.transactionExists(transaction4) == false) {
    //     pool.addTransaction(transaction4);
    // }

    // Block last_block2 = blockchain.blocks[blockchain.blocks.size()-1];
    // std::string lastHash2 = last_block2.hash;
    // unsigned long long blockCount2 = last_block2.blockCount + 1;
    
    // Block block2 = sonny_wallet.createBlock(pool.transactions, lastHash2, blockCount2);

    // bool signature_valid2 = false;
    // if (!blockchain.lastBlockHashValid(block2))
    //     std::cout << "Last block hash is not valid" << std::endl;
    // if (!blockchain.blockCountValid(block2))
    //     std::cout << "Last block count is not valid" << std::endl;
    // if (!utils::verifySignature(block2.payload(), block2.signature, sonny_wallet.walletPublicKey))
    //     std::cout << "Block signature is not valid: " + block2.signature << std::endl;
    // else
    //     signature_valid2 = true;

    // if (blockchain.lastBlockHashValid(block) 
    //         && blockchain.blockCountValid(block)
    //         && signature_valid2) {   
    //     blockchain.addBlock(block2);
    //     pool.transactions.clear();
    // }